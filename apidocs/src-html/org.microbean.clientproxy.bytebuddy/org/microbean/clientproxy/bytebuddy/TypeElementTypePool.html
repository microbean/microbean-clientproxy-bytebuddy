<!DOCTYPE HTML>
<html lang>
<head>
<!-- Generated by javadoc (23) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: module: org.microbean.clientproxy.bytebuddy, package: org.microbean.clientproxy.bytebuddy, class: TypeElementTypePool">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../resource-files/stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">/* -*- mode: Java; c-basic-offset: 2; indent-tabs-mode: nil; coding: utf-8-unix -*-</span>
<span class="source-line-no">002</span><span id="line-2"> *</span>
<span class="source-line-no">003</span><span id="line-3"> * Copyright © 2025 microBean™.</span>
<span class="source-line-no">004</span><span id="line-4"> *</span>
<span class="source-line-no">005</span><span id="line-5"> * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with</span>
<span class="source-line-no">006</span><span id="line-6"> * the License. You may obtain a copy of the License at</span>
<span class="source-line-no">007</span><span id="line-7"> *</span>
<span class="source-line-no">008</span><span id="line-8"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="source-line-no">009</span><span id="line-9"> *</span>
<span class="source-line-no">010</span><span id="line-10"> * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on</span>
<span class="source-line-no">011</span><span id="line-11"> * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the</span>
<span class="source-line-no">012</span><span id="line-12"> * specific language governing permissions and limitations under the License.</span>
<span class="source-line-no">013</span><span id="line-13"> */</span>
<span class="source-line-no">014</span><span id="line-14">package org.microbean.clientproxy.bytebuddy;</span>
<span class="source-line-no">015</span><span id="line-15"></span>
<span class="source-line-no">016</span><span id="line-16">import java.util.ArrayList;</span>
<span class="source-line-no">017</span><span id="line-17">import java.util.Collections;</span>
<span class="source-line-no">018</span><span id="line-18">import java.util.List;</span>
<span class="source-line-no">019</span><span id="line-19">import java.util.Map;</span>
<span class="source-line-no">020</span><span id="line-20">import java.util.Objects;</span>
<span class="source-line-no">021</span><span id="line-21"></span>
<span class="source-line-no">022</span><span id="line-22">import javax.lang.model.element.Element;</span>
<span class="source-line-no">023</span><span id="line-23">import javax.lang.model.element.ElementKind;</span>
<span class="source-line-no">024</span><span id="line-24">import javax.lang.model.element.ExecutableElement;</span>
<span class="source-line-no">025</span><span id="line-25">import javax.lang.model.element.NestingKind;</span>
<span class="source-line-no">026</span><span id="line-26">import javax.lang.model.element.RecordComponentElement;</span>
<span class="source-line-no">027</span><span id="line-27">import javax.lang.model.element.TypeElement;</span>
<span class="source-line-no">028</span><span id="line-28">import javax.lang.model.element.VariableElement;</span>
<span class="source-line-no">029</span><span id="line-29"></span>
<span class="source-line-no">030</span><span id="line-30">import javax.lang.model.type.DeclaredType;</span>
<span class="source-line-no">031</span><span id="line-31">import javax.lang.model.type.TypeKind;</span>
<span class="source-line-no">032</span><span id="line-32">import javax.lang.model.type.TypeMirror;</span>
<span class="source-line-no">033</span><span id="line-33">import javax.lang.model.type.TypeVariable;</span>
<span class="source-line-no">034</span><span id="line-34"></span>
<span class="source-line-no">035</span><span id="line-35">import net.bytebuddy.ClassFileVersion;</span>
<span class="source-line-no">036</span><span id="line-36"></span>
<span class="source-line-no">037</span><span id="line-37">import net.bytebuddy.description.annotation.AnnotationValue;</span>
<span class="source-line-no">038</span><span id="line-38"></span>
<span class="source-line-no">039</span><span id="line-39">import net.bytebuddy.dynamic.ClassFileLocator;</span>
<span class="source-line-no">040</span><span id="line-40"></span>
<span class="source-line-no">041</span><span id="line-41">import net.bytebuddy.pool.TypePool;</span>
<span class="source-line-no">042</span><span id="line-42"></span>
<span class="source-line-no">043</span><span id="line-43">import org.microbean.construct.Domain;</span>
<span class="source-line-no">044</span><span id="line-44"></span>
<span class="source-line-no">045</span><span id="line-45">import org.microbean.construct.vm.AccessFlags;</span>
<span class="source-line-no">046</span><span id="line-46">import org.microbean.construct.vm.Signatures;</span>
<span class="source-line-no">047</span><span id="line-47">import org.microbean.construct.vm.TypeDescriptors;</span>
<span class="source-line-no">048</span><span id="line-48"></span>
<span class="source-line-no">049</span><span id="line-49">/**</span>
<span class="source-line-no">050</span><span id="line-50"> * A {@link TypePool.Default} that produces {@link net.bytebuddy.description.type.TypeDescription}s from {@code</span>
<span class="source-line-no">051</span><span id="line-51"> * javax.lang.model.*} constructs.</span>
<span class="source-line-no">052</span><span id="line-52"> *</span>
<span class="source-line-no">053</span><span id="line-53"> * &lt;p&gt;Notably, this approach does not cause classloading to occur.&lt;/p&gt;</span>
<span class="source-line-no">054</span><span id="line-54"> *</span>
<span class="source-line-no">055</span><span id="line-55"> * @author &lt;a href="https://about.me/lairdnelson/" target="_top"&gt;Laird Nelson&lt;/a&gt;</span>
<span class="source-line-no">056</span><span id="line-56"> *</span>
<span class="source-line-no">057</span><span id="line-57"> * @see #doDescribe(String)</span>
<span class="source-line-no">058</span><span id="line-58"> */</span>
<span class="source-line-no">059</span><span id="line-59">public final class TypeElementTypePool extends TypePool.Default {</span>
<span class="source-line-no">060</span><span id="line-60"></span>
<span class="source-line-no">061</span><span id="line-61"></span>
<span class="source-line-no">062</span><span id="line-62">  /*</span>
<span class="source-line-no">063</span><span id="line-63">   * Instance fields.</span>
<span class="source-line-no">064</span><span id="line-64">   */</span>
<span class="source-line-no">065</span><span id="line-65"></span>
<span class="source-line-no">066</span><span id="line-66"></span>
<span class="source-line-no">067</span><span id="line-67">  private final ClassFileVersion classFileVersion;</span>
<span class="source-line-no">068</span><span id="line-68"></span>
<span class="source-line-no">069</span><span id="line-69">  private final Domain domain;</span>
<span class="source-line-no">070</span><span id="line-70"></span>
<span class="source-line-no">071</span><span id="line-71"></span>
<span class="source-line-no">072</span><span id="line-72">  /*</span>
<span class="source-line-no">073</span><span id="line-73">   * Constructors.</span>
<span class="source-line-no">074</span><span id="line-74">   */</span>
<span class="source-line-no">075</span><span id="line-75"></span>
<span class="source-line-no">076</span><span id="line-76"></span>
<span class="source-line-no">077</span><span id="line-77">  /**</span>
<span class="source-line-no">078</span><span id="line-78">   * Creates a new {@link TypeElementTypePool}.</span>
<span class="source-line-no">079</span><span id="line-79">   *</span>
<span class="source-line-no">080</span><span id="line-80">   * @param domain a {@link Domain}; must not be {@code null}</span>
<span class="source-line-no">081</span><span id="line-81">   *</span>
<span class="source-line-no">082</span><span id="line-82">   * @exception NullPointerException if {@code domain} is {@code null}</span>
<span class="source-line-no">083</span><span id="line-83">   *</span>
<span class="source-line-no">084</span><span id="line-84">   * @see #TypeElementTypePool(ClassFileVersion, TypePool.CacheProvider, Domain)</span>
<span class="source-line-no">085</span><span id="line-85">   */</span>
<span class="source-line-no">086</span><span id="line-86">  public TypeElementTypePool(final Domain domain) {</span>
<span class="source-line-no">087</span><span id="line-87">    this(null, null, domain);</span>
<span class="source-line-no">088</span><span id="line-88">  }</span>
<span class="source-line-no">089</span><span id="line-89"></span>
<span class="source-line-no">090</span><span id="line-90">  /**</span>
<span class="source-line-no">091</span><span id="line-91">   * Creates a new {@link TypeElementTypePool}.</span>
<span class="source-line-no">092</span><span id="line-92">   *</span>
<span class="source-line-no">093</span><span id="line-93">   * @param cacheProvider a {@link TypePool.CacheProvider}; may be {@code null} in which case a new {@link</span>
<span class="source-line-no">094</span><span id="line-94">   * TypePool.CacheProvider.Simple} will be used instead</span>
<span class="source-line-no">095</span><span id="line-95">   *</span>
<span class="source-line-no">096</span><span id="line-96">   * @param domain a {@link Domain}; must not be {@code null}</span>
<span class="source-line-no">097</span><span id="line-97">   *</span>
<span class="source-line-no">098</span><span id="line-98">   * @exception NullPointerException if {@code domain} is {@code null}</span>
<span class="source-line-no">099</span><span id="line-99">   *</span>
<span class="source-line-no">100</span><span id="line-100">   * @see #TypeElementTypePool(ClassFileVersion, TypePool.CacheProvider, Domain)</span>
<span class="source-line-no">101</span><span id="line-101">   */</span>
<span class="source-line-no">102</span><span id="line-102">  public TypeElementTypePool(final TypePool.CacheProvider cacheProvider, final Domain domain) {</span>
<span class="source-line-no">103</span><span id="line-103">    this(null, cacheProvider, domain);</span>
<span class="source-line-no">104</span><span id="line-104">  }</span>
<span class="source-line-no">105</span><span id="line-105"></span>
<span class="source-line-no">106</span><span id="line-106">  /**</span>
<span class="source-line-no">107</span><span id="line-107">   * Creates a new {@link TypeElementTypePool}.</span>
<span class="source-line-no">108</span><span id="line-108">   *</span>
<span class="source-line-no">109</span><span id="line-109">   * @param classFileVersion a {@link ClassFileVersion}; may be {@code null} in which case the return value of an</span>
<span class="source-line-no">110</span><span id="line-110">   * invocation of {@link ClassFileVersion#ofThisVm()} will be used instead</span>
<span class="source-line-no">111</span><span id="line-111">   *</span>
<span class="source-line-no">112</span><span id="line-112">   * @param cacheProvider a {@link TypePool.CacheProvider}; may be {@code null} in which case a new {@link</span>
<span class="source-line-no">113</span><span id="line-113">   * TypePool.CacheProvider.Simple} will be used instead</span>
<span class="source-line-no">114</span><span id="line-114">   *</span>
<span class="source-line-no">115</span><span id="line-115">   * @param domain a {@link Domain}; must not be {@code null}</span>
<span class="source-line-no">116</span><span id="line-116">   *</span>
<span class="source-line-no">117</span><span id="line-117">   * @exception NullPointerException if {@code domain} is {@code null}</span>
<span class="source-line-no">118</span><span id="line-118">   */</span>
<span class="source-line-no">119</span><span id="line-119">  public TypeElementTypePool(final ClassFileVersion classFileVersion,</span>
<span class="source-line-no">120</span><span id="line-120">                             final TypePool.CacheProvider cacheProvider,</span>
<span class="source-line-no">121</span><span id="line-121">                             final Domain domain) {</span>
<span class="source-line-no">122</span><span id="line-122">    super(cacheProvider == null ? new TypePool.CacheProvider.Simple() : cacheProvider,</span>
<span class="source-line-no">123</span><span id="line-123">          ClassFileLocator.NoOp.INSTANCE, // no locator</span>
<span class="source-line-no">124</span><span id="line-124">          TypePool.Default.ReaderMode.FAST); // irrelevant; doesn't read class files</span>
<span class="source-line-no">125</span><span id="line-125">    this.domain = Objects.requireNonNull(domain, "domain");</span>
<span class="source-line-no">126</span><span id="line-126">    this.classFileVersion = classFileVersion == null ? ClassFileVersion.ofThisVm() : classFileVersion;</span>
<span class="source-line-no">127</span><span id="line-127">  }</span>
<span class="source-line-no">128</span><span id="line-128"></span>
<span class="source-line-no">129</span><span id="line-129"></span>
<span class="source-line-no">130</span><span id="line-130">  /*</span>
<span class="source-line-no">131</span><span id="line-131">   * Instance methods.</span>
<span class="source-line-no">132</span><span id="line-132">   */</span>
<span class="source-line-no">133</span><span id="line-133"></span>
<span class="source-line-no">134</span><span id="line-134"></span>
<span class="source-line-no">135</span><span id="line-135">  /**</span>
<span class="source-line-no">136</span><span id="line-136">   * Given a name of an only partially defined format that names a Java language array, primitive, or declared type, or</span>
<span class="source-line-no">137</span><span id="line-137">   * the {@code void} type, returns a {@link Resolution} describing a {@link TypeDescription} corresponding to that</span>
<span class="source-line-no">138</span><span id="line-138">   * name.</span>
<span class="source-line-no">139</span><span id="line-139">   *</span>
<span class="source-line-no">140</span><span id="line-140">   * &lt;p&gt;The {@linkplain #describe(String)} method, which this one overrides only for documentation purposes, does not</span>
<span class="source-line-no">141</span><span id="line-141">   * document what the supplied {@code name} must be beyond this:&lt;/p&gt;</span>
<span class="source-line-no">142</span><span id="line-142">   *</span>
<span class="source-line-no">143</span><span id="line-143">   * &lt;blockquote&gt;The name of the type to describe. The name is to be written as when calling {@link Class#getName()</span>
<span class="source-line-no">144</span><span id="line-144">   * Class.getName()}.&lt;/blockquote&gt;</span>
<span class="source-line-no">145</span><span id="line-145">   *</span>
<span class="source-line-no">146</span><span id="line-146">   * &lt;p&gt;We call names of this sort &lt;dfn&gt;type pool names&lt;/dfn&gt;.&lt;/p&gt;</span>
<span class="source-line-no">147</span><span id="line-147">   *</span>
<span class="source-line-no">148</span><span id="line-148">   * @param typePoolName a &lt;dfn&gt;type pool name&lt;/dfn&gt; whose validity requirements are expressed only in &lt;a</span>
<span class="source-line-no">149</span><span id="line-149">   * href="https://github.com/raphw/byte-buddy/blob/byte-buddy-1.16.0/byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java#L576-L602"&gt;source</span>
<span class="source-line-no">150</span><span id="line-150">   * code&lt;/a&gt;; must not be {@code null}</span>
<span class="source-line-no">151</span><span id="line-151">   *</span>
<span class="source-line-no">152</span><span id="line-152">   * @return a non-{@code null} {@link Resolution}</span>
<span class="source-line-no">153</span><span id="line-153">   *</span>
<span class="source-line-no">154</span><span id="line-154">   * @exception NullPointerException if {@code typePoolName} is {@code null}</span>
<span class="source-line-no">155</span><span id="line-155">   *</span>
<span class="source-line-no">156</span><span id="line-156">   * @see TypePool#describe(String)</span>
<span class="source-line-no">157</span><span id="line-157">   *</span>
<span class="source-line-no">158</span><span id="line-158">   * @see Class#forName(String)</span>
<span class="source-line-no">159</span><span id="line-159">   *</span>
<span class="source-line-no">160</span><span id="line-160">   * @see Class#getName()</span>
<span class="source-line-no">161</span><span id="line-161">   *</span>
<span class="source-line-no">162</span><span id="line-162">   * @see Domain#typeElement(CharSequence)</span>
<span class="source-line-no">163</span><span id="line-163">   *</span>
<span class="source-line-no">164</span><span id="line-164">   * @see &lt;a</span>
<span class="source-line-no">165</span><span id="line-165">   * href="https://github.com/raphw/byte-buddy/blob/byte-buddy-1.16.0/byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java#L576-L602"&gt;Source</span>
<span class="source-line-no">166</span><span id="line-166">   * code for the &lt;code&gt;TypePool.AbstractBase&lt;/code&gt; class&lt;/a&gt;</span>
<span class="source-line-no">167</span><span id="line-167">   *</span>
<span class="source-line-no">168</span><span id="line-168">   * @see &lt;a href="https://github.com/raphw/byte-buddy/issues/1754"&gt;Byte Buddy issue 1754&lt;/a&gt;</span>
<span class="source-line-no">169</span><span id="line-169">   *</span>
<span class="source-line-no">170</span><span id="line-170">   * @spec https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.7 Java Language Specification, section</span>
<span class="source-line-no">171</span><span id="line-171">   * 6.7</span>
<span class="source-line-no">172</span><span id="line-172">   *</span>
<span class="source-line-no">173</span><span id="line-173">   * @spec https://docs.oracle.com/javase/specs/jls/se23/html/jls-13.html#jls-13.1 Java Language Specification, section</span>
<span class="source-line-no">174</span><span id="line-174">   * 13.1</span>
<span class="source-line-no">175</span><span id="line-175">   *</span>
<span class="source-line-no">176</span><span id="line-176">   * @spec https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.7.9.1 Java Virtual Machine</span>
<span class="source-line-no">177</span><span id="line-177">   * Specification, section 4.7.9.1</span>
<span class="source-line-no">178</span><span id="line-178">   */</span>
<span class="source-line-no">179</span><span id="line-179">  @Override // TypePool.Default</span>
<span class="source-line-no">180</span><span id="line-180">  public final Resolution describe(final String typePoolName) {</span>
<span class="source-line-no">181</span><span id="line-181">    // https://github.com/raphw/byte-buddy/blob/byte-buddy-1.16.0/byte-buddy-dep/src/main/java/net/bytebuddy/pool/TypePool.java#L576-L602</span>
<span class="source-line-no">182</span><span id="line-182">    return super.describe(typePoolName);</span>
<span class="source-line-no">183</span><span id="line-183">  }</span>
<span class="source-line-no">184</span><span id="line-184"></span>
<span class="source-line-no">185</span><span id="line-185">  @Override // TypePool.Default</span>
<span class="source-line-no">186</span><span id="line-186">  protected final Resolution doDescribe(final String binaryName) {</span>
<span class="source-line-no">187</span><span id="line-187">    // Note that we deliberately and I believe properly do not use the two-argument form of</span>
<span class="source-line-no">188</span><span id="line-188">    // domain#typeElement(ModuleElement, CharSequence), since inferring the ModuleElement representing the caller here</span>
<span class="source-line-no">189</span><span id="line-189">    // is all but impossible (except for StackWalker).</span>
<span class="source-line-no">190</span><span id="line-190">    </span>
<span class="source-line-no">191</span><span id="line-191">    // If binaryName is the binary name of a top-level class, this will work just fine because a top level class' binary</span>
<span class="source-line-no">192</span><span id="line-192">    // and canonical names are the same, and canonical names are what domain#typeElement(CharSequence) accepts.</span>
<span class="source-line-no">193</span><span id="line-193">    TypeElement e = this.domain.typeElement(binaryName);</span>
<span class="source-line-no">194</span><span id="line-194">    if (e == null) {</span>
<span class="source-line-no">195</span><span id="line-195">      // If binaryName is not the binary name of a top-level class, then by the time we're in this method it is the</span>
<span class="source-line-no">196</span><span id="line-196">      // binary name of an inner or nested class, and there is no perfectly reliable way to convert such a binary name</span>
<span class="source-line-no">197</span><span id="line-197">      // into a canonical name (or, for that matter, to go the other way). For *most* cases, changing '$' to '.' to</span>
<span class="source-line-no">198</span><span id="line-198">      // yield a valid canonical name for an inner or nested class is good enough, so that's what we do here.</span>
<span class="source-line-no">199</span><span id="line-199">      e = this.domain.typeElement(binaryName.replace('$', '.'));</span>
<span class="source-line-no">200</span><span id="line-200">    }</span>
<span class="source-line-no">201</span><span id="line-201">    return</span>
<span class="source-line-no">202</span><span id="line-202">      e == null ?</span>
<span class="source-line-no">203</span><span id="line-203">      new Resolution.Illegal(binaryName + "; " + binaryName.replace('%', '.')) :</span>
<span class="source-line-no">204</span><span id="line-204">      new Resolution.Simple(new TypeDescription(this.domain, e));</span>
<span class="source-line-no">205</span><span id="line-205">  }</span>
<span class="source-line-no">206</span><span id="line-206"></span>
<span class="source-line-no">207</span><span id="line-207"></span>
<span class="source-line-no">208</span><span id="line-208">  /*</span>
<span class="source-line-no">209</span><span id="line-209">   * Inner and nested classes.</span>
<span class="source-line-no">210</span><span id="line-210">   */</span>
<span class="source-line-no">211</span><span id="line-211"></span>
<span class="source-line-no">212</span><span id="line-212"></span>
<span class="source-line-no">213</span><span id="line-213">  private final class TypeDescription extends LazyTypeDescription {</span>
<span class="source-line-no">214</span><span id="line-214"></span>
<span class="source-line-no">215</span><span id="line-215"></span>
<span class="source-line-no">216</span><span id="line-216">    /*</span>
<span class="source-line-no">217</span><span id="line-217">     * Static fields.</span>
<span class="source-line-no">218</span><span id="line-218">     */</span>
<span class="source-line-no">219</span><span id="line-219"></span>
<span class="source-line-no">220</span><span id="line-220"></span>
<span class="source-line-no">221</span><span id="line-221">    private static final String[] EMPTY_STRING_ARRAY = new String[0];</span>
<span class="source-line-no">222</span><span id="line-222"></span>
<span class="source-line-no">223</span><span id="line-223"></span>
<span class="source-line-no">224</span><span id="line-224">    /*</span>
<span class="source-line-no">225</span><span id="line-225">     * Constructors.</span>
<span class="source-line-no">226</span><span id="line-226">     */</span>
<span class="source-line-no">227</span><span id="line-227"></span>
<span class="source-line-no">228</span><span id="line-228"></span>
<span class="source-line-no">229</span><span id="line-229">    // Binary names in this mess are JVM binary names, not JLS binary names. Raph calls them "internal names" which</span>
<span class="source-line-no">230</span><span id="line-230">    // isn't a thing. He's probably referring to the paragraph in the Java Virtual Machine Specification section 4.3.1</span>
<span class="source-line-no">231</span><span id="line-231">    // that reads: "For historical reasons, the syntax of binary names that appear in class file structures differs from</span>
<span class="source-line-no">232</span><span id="line-232">    // the syntax of binary names documented in JLS §13.1. In this *internal* [emphasis mine] form, the ASCII periods</span>
<span class="source-line-no">233</span><span id="line-233">    // (.) that normally separate the identifiers which make up the binary name are replaced by ASCII forward slashes</span>
<span class="source-line-no">234</span><span id="line-234">    // (/). The identifiers themselves must be unqualified names (§4.2.2)." On the other hand, that is not the kind of</span>
<span class="source-line-no">235</span><span id="line-235">    // binary name returned by, for example, javax.lang.model.util.Elements#getBinaryName(TypeElement). So maybe ASM</span>
<span class="source-line-no">236</span><span id="line-236">    // does the conversion from "real" binary name to "internal" binary name and that's what he's talking about?</span>
<span class="source-line-no">237</span><span id="line-237">    //</span>
<span class="source-line-no">238</span><span id="line-238">    // The consumer of these sorts of names appears to be</span>
<span class="source-line-no">239</span><span id="line-239">    // https://asm.ow2.io/javadoc/org/objectweb/asm/signature/SignatureVisitor.html.</span>
<span class="source-line-no">240</span><span id="line-240">    //</span>
<span class="source-line-no">241</span><span id="line-241">    // Raph's javadoc for NamedElement#getInternalName() reads, in part: "The internal name of this byte code element as</span>
<span class="source-line-no">242</span><span id="line-242">    // used within the Java class file format", which suggests we should look at the JVM specification for answers. See,</span>
<span class="source-line-no">243</span><span id="line-243">    // for example, https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.7.9.1. Maybe those are the</span>
<span class="source-line-no">244</span><span id="line-244">    // sorts of things meant by "internal name"?</span>
<span class="source-line-no">245</span><span id="line-245">    //</span>
<span class="source-line-no">246</span><span id="line-246">    // See also https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.2.1.</span>
<span class="source-line-no">247</span><span id="line-247">    /**</span>
<span class="source-line-no">248</span><span id="line-248">     * Creates a new {@link TypeDescription}.</span>
<span class="source-line-no">249</span><span id="line-249">     *</span>
<span class="source-line-no">250</span><span id="line-250">     * @param domain a {@link Domain}; must not be {@code null}</span>
<span class="source-line-no">251</span><span id="line-251">     *</span>
<span class="source-line-no">252</span><span id="line-252">     * @param e a {@link TypeElement}; must not be {@code null}</span>
<span class="source-line-no">253</span><span id="line-253">     *</span>
<span class="source-line-no">254</span><span id="line-254">     * @exception NullPointerException if either argument is {@code null}</span>
<span class="source-line-no">255</span><span id="line-255">     *</span>
<span class="source-line-no">256</span><span id="line-256">     * @spec https://docs.oracle.com/javase/specs/jvms/se23/html/jvms-4.html#jvms-4.2.1 Java Virtual Machine</span>
<span class="source-line-no">257</span><span id="line-257">     * Specification, section 4.2.1</span>
<span class="source-line-no">258</span><span id="line-258">     */</span>
<span class="source-line-no">259</span><span id="line-259">    private TypeDescription(final Domain domain, final TypeElement e) {</span>
<span class="source-line-no">260</span><span id="line-260">      super(TypeElementTypePool.this,</span>
<span class="source-line-no">261</span><span id="line-261">            actualModifiers(domain, e),</span>
<span class="source-line-no">262</span><span id="line-262">            modifiers(domain, e),</span>
<span class="source-line-no">263</span><span id="line-263">            domain.toString(domain.binaryName(e)), // "internalName"</span>
<span class="source-line-no">264</span><span id="line-264">            binaryName(domain, e.getSuperclass()), // "superClassName"</span>
<span class="source-line-no">265</span><span id="line-265">            interfaceBinaryNames(domain, e), // "interfaceName" (yes, singular for some reason)</span>
<span class="source-line-no">266</span><span id="line-266">            genericSignature(domain, e), // "genericSignature"; ASM just calls it a "signature" and seems to be expecting a *type* signature in the JVM parlance</span>
<span class="source-line-no">267</span><span id="line-267">            typeContainment(domain, e),</span>
<span class="source-line-no">268</span><span id="line-268">            declaringTypeBinaryName(domain, e),</span>
<span class="source-line-no">269</span><span id="line-269">            declaredTypeDescriptors(domain, e),</span>
<span class="source-line-no">270</span><span id="line-270">            e.getNestingKind() == NestingKind.ANONYMOUS,</span>
<span class="source-line-no">271</span><span id="line-271">            nestHostBinaryName(e),</span>
<span class="source-line-no">272</span><span id="line-272">            nestMemberBinaryNames(e),</span>
<span class="source-line-no">273</span><span id="line-273">            superclassAnnotationTokens(e),</span>
<span class="source-line-no">274</span><span id="line-274">            interfaceAnnotationTokens(e),</span>
<span class="source-line-no">275</span><span id="line-275">            typeVariableAnnotationTokens(e),</span>
<span class="source-line-no">276</span><span id="line-276">            typeVariableBoundsAnnotationTokens(e),</span>
<span class="source-line-no">277</span><span id="line-277">            annotationTokens(e),</span>
<span class="source-line-no">278</span><span id="line-278">            fieldTokens(domain, e),</span>
<span class="source-line-no">279</span><span id="line-279">            methodTokens(domain, e),</span>
<span class="source-line-no">280</span><span id="line-280">            recordComponentTokens(domain, e),</span>
<span class="source-line-no">281</span><span id="line-281">            permittedSubclassBinaryNames(domain, e),</span>
<span class="source-line-no">282</span><span id="line-282">            classFileVersion);</span>
<span class="source-line-no">283</span><span id="line-283">    }</span>
<span class="source-line-no">284</span><span id="line-284"></span>
<span class="source-line-no">285</span><span id="line-285"></span>
<span class="source-line-no">286</span><span id="line-286">    /*</span>
<span class="source-line-no">287</span><span id="line-287">     * Static methods.</span>
<span class="source-line-no">288</span><span id="line-288">     */</span>
<span class="source-line-no">289</span><span id="line-289"></span>
<span class="source-line-no">290</span><span id="line-290"></span>
<span class="source-line-no">291</span><span id="line-291">    private static final String binaryName(final Domain domain, final TypeMirror t) {</span>
<span class="source-line-no">292</span><span id="line-292">      final Element e = domain.element(t);</span>
<span class="source-line-no">293</span><span id="line-293">      return e instanceof TypeElement te ? domain.toString(domain.binaryName(te)) : null;</span>
<span class="source-line-no">294</span><span id="line-294">    }</span>
<span class="source-line-no">295</span><span id="line-295"></span>
<span class="source-line-no">296</span><span id="line-296">    private static final int actualModifiers(final Domain domain, final Element e) {</span>
<span class="source-line-no">297</span><span id="line-297">      return AccessFlags.accessFlags(e, domain);</span>
<span class="source-line-no">298</span><span id="line-298">    }</span>
<span class="source-line-no">299</span><span id="line-299"></span>
<span class="source-line-no">300</span><span id="line-300">    private static final int modifiers(final Domain domain, final Element e) {</span>
<span class="source-line-no">301</span><span id="line-301">      return AccessFlags.accessFlags(e, domain);</span>
<span class="source-line-no">302</span><span id="line-302">    }</span>
<span class="source-line-no">303</span><span id="line-303"></span>
<span class="source-line-no">304</span><span id="line-304">    private static final String[] interfaceBinaryNames(final Domain domain, final TypeElement e) {</span>
<span class="source-line-no">305</span><span id="line-305">      final List&lt;? extends TypeMirror&gt; ifaces = e.getInterfaces();</span>
<span class="source-line-no">306</span><span id="line-306">      if (ifaces.isEmpty()) {</span>
<span class="source-line-no">307</span><span id="line-307">        return EMPTY_STRING_ARRAY;</span>
<span class="source-line-no">308</span><span id="line-308">      }</span>
<span class="source-line-no">309</span><span id="line-309">      final String[] rv = new String[ifaces.size()];</span>
<span class="source-line-no">310</span><span id="line-310">      for (int i = 0; i &lt; rv.length; i++) {</span>
<span class="source-line-no">311</span><span id="line-311">        rv[i] = binaryName(domain, ifaces.get(i));</span>
<span class="source-line-no">312</span><span id="line-312">      }</span>
<span class="source-line-no">313</span><span id="line-313">      return rv;</span>
<span class="source-line-no">314</span><span id="line-314">    }</span>
<span class="source-line-no">315</span><span id="line-315"></span>
<span class="source-line-no">316</span><span id="line-316">    private static final String genericSignature(final Domain domain, final Element e) {</span>
<span class="source-line-no">317</span><span id="line-317">      return Signatures.signature(e, domain);</span>
<span class="source-line-no">318</span><span id="line-318">      // return domain.elementSignature(e);</span>
<span class="source-line-no">319</span><span id="line-319">    }</span>
<span class="source-line-no">320</span><span id="line-320"></span>
<span class="source-line-no">321</span><span id="line-321">    private static final TypeContainment typeContainment(final Domain domain, final Element e) {</span>
<span class="source-line-no">322</span><span id="line-322">      final TypeElement ee = (TypeElement)e.getEnclosingElement();</span>
<span class="source-line-no">323</span><span id="line-323">      if (ee == null) {</span>
<span class="source-line-no">324</span><span id="line-324">        return TypeContainment.SelfContained.INSTANCE;</span>
<span class="source-line-no">325</span><span id="line-325">      }</span>
<span class="source-line-no">326</span><span id="line-326">      return switch (ee.getKind()) {</span>
<span class="source-line-no">327</span><span id="line-327">      case METHOD -&gt;</span>
<span class="source-line-no">328</span><span id="line-328">        new TypeContainment.WithinMethod(domain.toString(domain.binaryName((TypeElement)ee.getEnclosingElement())),</span>
<span class="source-line-no">329</span><span id="line-329">                                         domain.toString(ee.getSimpleName()), // TODO: maybe? needs to be method's "internal name" which is just its "unqualified name" (4.2.2 JVM)</span>
<span class="source-line-no">330</span><span id="line-330">                                         TypeDescriptors.typeDescriptor(ee.asType(), domain).descriptorString()) {};</span>
<span class="source-line-no">331</span><span id="line-331">      case ANNOTATION_TYPE, CLASS, ENUM, INTERFACE, RECORD -&gt;</span>
<span class="source-line-no">332</span><span id="line-332">        new TypeContainment.WithinType(domain.toString(domain.binaryName(ee)),</span>
<span class="source-line-no">333</span><span id="line-333">                                       ee.getNestingKind() == NestingKind.LOCAL) {}; // TODO: this is for the enclosing element, yes?</span>
<span class="source-line-no">334</span><span id="line-334">      case PACKAGE -&gt; TypeContainment.SelfContained.INSTANCE;</span>
<span class="source-line-no">335</span><span id="line-335">      default -&gt; throw new IllegalStateException(); // I guess?</span>
<span class="source-line-no">336</span><span id="line-336">      };</span>
<span class="source-line-no">337</span><span id="line-337">    }</span>
<span class="source-line-no">338</span><span id="line-338"></span>
<span class="source-line-no">339</span><span id="line-339">    private static final String declaringTypeBinaryName(final Domain domain, final TypeElement e) {</span>
<span class="source-line-no">340</span><span id="line-340">      // TODO: triple check: getEnclosingType()? or getEnclosingElement.asType()?</span>
<span class="source-line-no">341</span><span id="line-341">      final TypeMirror t = ((DeclaredType)e.asType()).getEnclosingType();</span>
<span class="source-line-no">342</span><span id="line-342">      if (t == null || t.getKind() == TypeKind.NONE) {</span>
<span class="source-line-no">343</span><span id="line-343">        return null;</span>
<span class="source-line-no">344</span><span id="line-344">      }</span>
<span class="source-line-no">345</span><span id="line-345">      return domain.toString(domain.binaryName((TypeElement)((DeclaredType)t).asElement()));</span>
<span class="source-line-no">346</span><span id="line-346">    }</span>
<span class="source-line-no">347</span><span id="line-347"></span>
<span class="source-line-no">348</span><span id="line-348">    private static final List&lt;String&gt; declaredTypeDescriptors(final Domain domain, final Element e) {</span>
<span class="source-line-no">349</span><span id="line-349">      final ArrayList&lt;String&gt; l = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">350</span><span id="line-350">      for (final Element ee : e.getEnclosedElements()) {</span>
<span class="source-line-no">351</span><span id="line-351">        if (ee.getKind().isDeclaredType()) {</span>
<span class="source-line-no">352</span><span id="line-352">          l.add(TypeDescriptors.typeDescriptor(ee.asType(), domain).descriptorString());</span>
<span class="source-line-no">353</span><span id="line-353">        }</span>
<span class="source-line-no">354</span><span id="line-354">      }</span>
<span class="source-line-no">355</span><span id="line-355">      l.trimToSize();</span>
<span class="source-line-no">356</span><span id="line-356">      return Collections.unmodifiableList(l);</span>
<span class="source-line-no">357</span><span id="line-357">    }</span>
<span class="source-line-no">358</span><span id="line-358"></span>
<span class="source-line-no">359</span><span id="line-359">    private static final String nestHostBinaryName(final Element e) {</span>
<span class="source-line-no">360</span><span id="line-360">      return null;</span>
<span class="source-line-no">361</span><span id="line-361">    }</span>
<span class="source-line-no">362</span><span id="line-362"></span>
<span class="source-line-no">363</span><span id="line-363">    private static final List&lt;String&gt; nestMemberBinaryNames(final Element e) {</span>
<span class="source-line-no">364</span><span id="line-364">      return List.of();</span>
<span class="source-line-no">365</span><span id="line-365">    }</span>
<span class="source-line-no">366</span><span id="line-366"></span>
<span class="source-line-no">367</span><span id="line-367">    private static final Map&lt;String, List&lt;AnnotationToken&gt;&gt; superclassAnnotationTokens(final Element e) {</span>
<span class="source-line-no">368</span><span id="line-368">      return Map.of();</span>
<span class="source-line-no">369</span><span id="line-369">    }</span>
<span class="source-line-no">370</span><span id="line-370"></span>
<span class="source-line-no">371</span><span id="line-371">    private static final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; interfaceAnnotationTokens(final Element e) {</span>
<span class="source-line-no">372</span><span id="line-372">      return Map.of();</span>
<span class="source-line-no">373</span><span id="line-373">    }</span>
<span class="source-line-no">374</span><span id="line-374"></span>
<span class="source-line-no">375</span><span id="line-375">    private static final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens(final Element e) {</span>
<span class="source-line-no">376</span><span id="line-376">      return Map.of();</span>
<span class="source-line-no">377</span><span id="line-377">    }</span>
<span class="source-line-no">378</span><span id="line-378"></span>
<span class="source-line-no">379</span><span id="line-379">    private static final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens(final Element e) {</span>
<span class="source-line-no">380</span><span id="line-380">      return Map.of();</span>
<span class="source-line-no">381</span><span id="line-381">    }</span>
<span class="source-line-no">382</span><span id="line-382"></span>
<span class="source-line-no">383</span><span id="line-383">    private static final List&lt;AnnotationToken&gt; annotationTokens(final Element e) {</span>
<span class="source-line-no">384</span><span id="line-384">      return List.of();</span>
<span class="source-line-no">385</span><span id="line-385">    }</span>
<span class="source-line-no">386</span><span id="line-386"></span>
<span class="source-line-no">387</span><span id="line-387">    private static final List&lt;FieldToken&gt; fieldTokens(final Domain domain, final Element e) {</span>
<span class="source-line-no">388</span><span id="line-388">      final ArrayList&lt;FieldToken&gt; l = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">389</span><span id="line-389">      for (final Element ee : e.getEnclosedElements()) {</span>
<span class="source-line-no">390</span><span id="line-390">        if (ee.getKind().isField()) {</span>
<span class="source-line-no">391</span><span id="line-391">          l.add(fieldToken(domain, (VariableElement)ee));</span>
<span class="source-line-no">392</span><span id="line-392">        }</span>
<span class="source-line-no">393</span><span id="line-393">      }</span>
<span class="source-line-no">394</span><span id="line-394">      l.trimToSize();</span>
<span class="source-line-no">395</span><span id="line-395">      return Collections.unmodifiableList(l);</span>
<span class="source-line-no">396</span><span id="line-396">    }</span>
<span class="source-line-no">397</span><span id="line-397"></span>
<span class="source-line-no">398</span><span id="line-398">    private static final List&lt;MethodToken&gt; methodTokens(final Domain domain, final Element e) {</span>
<span class="source-line-no">399</span><span id="line-399">      final ArrayList&lt;MethodToken&gt; l = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">400</span><span id="line-400">      for (final Element ee : e.getEnclosedElements()) {</span>
<span class="source-line-no">401</span><span id="line-401">        if (ee.getKind().isExecutable()) {</span>
<span class="source-line-no">402</span><span id="line-402">          l.add(methodToken(domain, (ExecutableElement)ee));</span>
<span class="source-line-no">403</span><span id="line-403">        }</span>
<span class="source-line-no">404</span><span id="line-404">      }</span>
<span class="source-line-no">405</span><span id="line-405">      l.trimToSize();</span>
<span class="source-line-no">406</span><span id="line-406">      return Collections.unmodifiableList(l);</span>
<span class="source-line-no">407</span><span id="line-407">    }</span>
<span class="source-line-no">408</span><span id="line-408"></span>
<span class="source-line-no">409</span><span id="line-409">    private static final List&lt;RecordComponentToken&gt; recordComponentTokens(final Domain domain, final Element e) {</span>
<span class="source-line-no">410</span><span id="line-410">      final ArrayList&lt;RecordComponentToken&gt; l = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">411</span><span id="line-411">      for (final Element ee : e.getEnclosedElements()) {</span>
<span class="source-line-no">412</span><span id="line-412">        if (ee.getKind() == ElementKind.RECORD_COMPONENT) {</span>
<span class="source-line-no">413</span><span id="line-413">          l.add(recordComponentToken(domain, (RecordComponentElement)ee));</span>
<span class="source-line-no">414</span><span id="line-414">        }</span>
<span class="source-line-no">415</span><span id="line-415">      }</span>
<span class="source-line-no">416</span><span id="line-416">      l.trimToSize();</span>
<span class="source-line-no">417</span><span id="line-417">      return Collections.unmodifiableList(l);</span>
<span class="source-line-no">418</span><span id="line-418">    }</span>
<span class="source-line-no">419</span><span id="line-419"></span>
<span class="source-line-no">420</span><span id="line-420">    private static final List&lt;String&gt; permittedSubclassBinaryNames(final Domain domain, final TypeElement e) {</span>
<span class="source-line-no">421</span><span id="line-421">      final List&lt;? extends TypeMirror&gt; ts = e.getPermittedSubclasses();</span>
<span class="source-line-no">422</span><span id="line-422">      if (ts.isEmpty()) {</span>
<span class="source-line-no">423</span><span id="line-423">        return List.of();</span>
<span class="source-line-no">424</span><span id="line-424">      }</span>
<span class="source-line-no">425</span><span id="line-425">      final List&lt;String&gt; l = new ArrayList&lt;&gt;(ts.size());</span>
<span class="source-line-no">426</span><span id="line-426">      for (final TypeMirror t : ts) {</span>
<span class="source-line-no">427</span><span id="line-427">        l.add(domain.toString(domain.binaryName((TypeElement)((DeclaredType)t).asElement())));</span>
<span class="source-line-no">428</span><span id="line-428">      }</span>
<span class="source-line-no">429</span><span id="line-429">      return Collections.unmodifiableList(l);</span>
<span class="source-line-no">430</span><span id="line-430">    }</span>
<span class="source-line-no">431</span><span id="line-431"></span>
<span class="source-line-no">432</span><span id="line-432">    private static final FieldToken fieldToken(final Domain domain, final VariableElement e) {</span>
<span class="source-line-no">433</span><span id="line-433">      if (!e.getKind().isField()) {</span>
<span class="source-line-no">434</span><span id="line-434">        throw new IllegalArgumentException("e: " + e);</span>
<span class="source-line-no">435</span><span id="line-435">      }</span>
<span class="source-line-no">436</span><span id="line-436">      return</span>
<span class="source-line-no">437</span><span id="line-437">        new FieldToken(domain.toString(e.getSimpleName()),</span>
<span class="source-line-no">438</span><span id="line-438">                       AccessFlags.accessFlags(e, domain),</span>
<span class="source-line-no">439</span><span id="line-439">                       TypeDescriptors.typeDescriptor(e.asType(), domain).descriptorString(),</span>
<span class="source-line-no">440</span><span id="line-440">                       genericSignature(domain, e),</span>
<span class="source-line-no">441</span><span id="line-441">                       Map.of(), // TODO: typeAnnotationTokens</span>
<span class="source-line-no">442</span><span id="line-442">                       List.of()) {}; // TODO: annotationTokens</span>
<span class="source-line-no">443</span><span id="line-443">    }</span>
<span class="source-line-no">444</span><span id="line-444"></span>
<span class="source-line-no">445</span><span id="line-445">    private static final MethodToken methodToken(final Domain domain, final ExecutableElement e) {</span>
<span class="source-line-no">446</span><span id="line-446">      final List&lt;? extends TypeMirror&gt; thrownTypes = e.getThrownTypes();</span>
<span class="source-line-no">447</span><span id="line-447">      final String[] exceptionBinaryNames;</span>
<span class="source-line-no">448</span><span id="line-448">      if (thrownTypes.isEmpty()) {</span>
<span class="source-line-no">449</span><span id="line-449">        exceptionBinaryNames = EMPTY_STRING_ARRAY;</span>
<span class="source-line-no">450</span><span id="line-450">      } else {</span>
<span class="source-line-no">451</span><span id="line-451">        exceptionBinaryNames = new String[thrownTypes.size()];</span>
<span class="source-line-no">452</span><span id="line-452">        for (int i = 0; i &lt; exceptionBinaryNames.length; i++) {</span>
<span class="source-line-no">453</span><span id="line-453">          exceptionBinaryNames[i] = domain.toString(domain.binaryName((TypeElement)((DeclaredType)thrownTypes.get(i)).asElement()));</span>
<span class="source-line-no">454</span><span id="line-454">        }</span>
<span class="source-line-no">455</span><span id="line-455">      }</span>
<span class="source-line-no">456</span><span id="line-456">      final ArrayList&lt;MethodTokenSubclass.ParameterTokenSubclass&gt; parameterTokens = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">457</span><span id="line-457">      for (final VariableElement p : e.getParameters()) {</span>
<span class="source-line-no">458</span><span id="line-458">        parameterTokens.add(parameterToken(domain, p));</span>
<span class="source-line-no">459</span><span id="line-459">      }</span>
<span class="source-line-no">460</span><span id="line-460">      parameterTokens.trimToSize();</span>
<span class="source-line-no">461</span><span id="line-461">      return</span>
<span class="source-line-no">462</span><span id="line-462">        new MethodTokenSubclass(domain.toString(e.getSimpleName()),</span>
<span class="source-line-no">463</span><span id="line-463">                                AccessFlags.accessFlags(e, domain),</span>
<span class="source-line-no">464</span><span id="line-464">                                TypeDescriptors.typeDescriptor(e.asType(), domain).descriptorString(),</span>
<span class="source-line-no">465</span><span id="line-465">                                genericSignature(domain, e),</span>
<span class="source-line-no">466</span><span id="line-466">                                exceptionBinaryNames,</span>
<span class="source-line-no">467</span><span id="line-467">                                typeVariableAnnotationTokens(e),</span>
<span class="source-line-no">468</span><span id="line-468">                                typeVariableBoundsAnnotationTokens(e),</span>
<span class="source-line-no">469</span><span id="line-469">                                Map.of(), // returnTypeAnnotationTokens</span>
<span class="source-line-no">470</span><span id="line-470">                                Map.of(), // parameterTypeAnnotationTokens</span>
<span class="source-line-no">471</span><span id="line-471">                                Map.of(), // exceptionTypeAnnotationTokens</span>
<span class="source-line-no">472</span><span id="line-472">                                Map.of(), // receiverTypeAnnotationTokens</span>
<span class="source-line-no">473</span><span id="line-473">                                annotationTokens(e),</span>
<span class="source-line-no">474</span><span id="line-474">                                Map.of(), // parameterAnnotationTokens</span>
<span class="source-line-no">475</span><span id="line-475">                                Collections.unmodifiableList(parameterTokens),</span>
<span class="source-line-no">476</span><span id="line-476">                                null); // defaultValue</span>
<span class="source-line-no">477</span><span id="line-477">    }</span>
<span class="source-line-no">478</span><span id="line-478"></span>
<span class="source-line-no">479</span><span id="line-479">    private static final MethodTokenSubclass.ParameterTokenSubclass parameterToken(final Domain domain, final VariableElement e) {</span>
<span class="source-line-no">480</span><span id="line-480">      final int accessFlags = AccessFlags.accessFlags(e, domain);</span>
<span class="source-line-no">481</span><span id="line-481">      return new MethodTokenSubclass.ParameterTokenSubclass(domain.toString(e.getSimpleName()), accessFlags == 0 ? null : Integer.valueOf(accessFlags));</span>
<span class="source-line-no">482</span><span id="line-482">    }</span>
<span class="source-line-no">483</span><span id="line-483"></span>
<span class="source-line-no">484</span><span id="line-484">    private static final RecordComponentToken recordComponentToken(final Domain domain, final RecordComponentElement e) {</span>
<span class="source-line-no">485</span><span id="line-485">      return</span>
<span class="source-line-no">486</span><span id="line-486">        new RecordComponentToken(domain.toString(e.getSimpleName()),</span>
<span class="source-line-no">487</span><span id="line-487">                                 TypeDescriptors.typeDescriptor(e.asType(), domain).descriptorString(),</span>
<span class="source-line-no">488</span><span id="line-488">                                 genericSignature(domain, e),</span>
<span class="source-line-no">489</span><span id="line-489">                                 Map.of(),</span>
<span class="source-line-no">490</span><span id="line-490">                                 List.of()) {}; // annotationTokens</span>
<span class="source-line-no">491</span><span id="line-491">    }</span>
<span class="source-line-no">492</span><span id="line-492"></span>
<span class="source-line-no">493</span><span id="line-493"></span>
<span class="source-line-no">494</span><span id="line-494">    /*</span>
<span class="source-line-no">495</span><span id="line-495">     * Inner and nested classes.</span>
<span class="source-line-no">496</span><span id="line-496">     */</span>
<span class="source-line-no">497</span><span id="line-497"></span>
<span class="source-line-no">498</span><span id="line-498"></span>
<span class="source-line-no">499</span><span id="line-499">    private static final class MethodTokenSubclass extends MethodToken {</span>
<span class="source-line-no">500</span><span id="line-500"></span>
<span class="source-line-no">501</span><span id="line-501"></span>
<span class="source-line-no">502</span><span id="line-502">      /*</span>
<span class="source-line-no">503</span><span id="line-503">       * Constructors.</span>
<span class="source-line-no">504</span><span id="line-504">       */</span>
<span class="source-line-no">505</span><span id="line-505"></span>
<span class="source-line-no">506</span><span id="line-506"></span>
<span class="source-line-no">507</span><span id="line-507">      @SuppressWarnings("unchecked")</span>
<span class="source-line-no">508</span><span id="line-508">      private MethodTokenSubclass(final String name,</span>
<span class="source-line-no">509</span><span id="line-509">                                  final int modifiers,</span>
<span class="source-line-no">510</span><span id="line-510">                                  final String descriptor,</span>
<span class="source-line-no">511</span><span id="line-511">                                  final String genericSignature,</span>
<span class="source-line-no">512</span><span id="line-512">                                  final String[] exceptionName,</span>
<span class="source-line-no">513</span><span id="line-513">                                  final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens,</span>
<span class="source-line-no">514</span><span id="line-514">                                  final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens,</span>
<span class="source-line-no">515</span><span id="line-515">                                  final Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens,</span>
<span class="source-line-no">516</span><span id="line-516">                                  final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens,</span>
<span class="source-line-no">517</span><span id="line-517">                                  final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens,</span>
<span class="source-line-no">518</span><span id="line-518">                                  final Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens,</span>
<span class="source-line-no">519</span><span id="line-519">                                  final List&lt;AnnotationToken&gt; annotationTokens,</span>
<span class="source-line-no">520</span><span id="line-520">                                  final Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens,</span>
<span class="source-line-no">521</span><span id="line-521">                                  final List&lt;? extends ParameterToken&gt; parameterTokens,</span>
<span class="source-line-no">522</span><span id="line-522">                                  final AnnotationValue&lt;?,?&gt; defaultValue) {</span>
<span class="source-line-no">523</span><span id="line-523">        super(name,</span>
<span class="source-line-no">524</span><span id="line-524">              modifiers,</span>
<span class="source-line-no">525</span><span id="line-525">              descriptor,</span>
<span class="source-line-no">526</span><span id="line-526">              genericSignature,</span>
<span class="source-line-no">527</span><span id="line-527">              exceptionName,</span>
<span class="source-line-no">528</span><span id="line-528">              typeVariableAnnotationTokens,</span>
<span class="source-line-no">529</span><span id="line-529">              typeVariableBoundAnnotationTokens,</span>
<span class="source-line-no">530</span><span id="line-530">              returnTypeAnnotationTokens,</span>
<span class="source-line-no">531</span><span id="line-531">              parameterTypeAnnotationTokens,</span>
<span class="source-line-no">532</span><span id="line-532">              exceptionTypeAnnotationTokens,</span>
<span class="source-line-no">533</span><span id="line-533">              receiverTypeAnnotationTokens,</span>
<span class="source-line-no">534</span><span id="line-534">              annotationTokens,</span>
<span class="source-line-no">535</span><span id="line-535">              parameterAnnotationTokens,</span>
<span class="source-line-no">536</span><span id="line-536">              (List&lt;ParameterToken&gt;)parameterTokens,</span>
<span class="source-line-no">537</span><span id="line-537">              defaultValue);</span>
<span class="source-line-no">538</span><span id="line-538">      }</span>
<span class="source-line-no">539</span><span id="line-539"></span>
<span class="source-line-no">540</span><span id="line-540"></span>
<span class="source-line-no">541</span><span id="line-541">      /*</span>
<span class="source-line-no">542</span><span id="line-542">       * Inner and nested classes.</span>
<span class="source-line-no">543</span><span id="line-543">       */</span>
<span class="source-line-no">544</span><span id="line-544"></span>
<span class="source-line-no">545</span><span id="line-545"></span>
<span class="source-line-no">546</span><span id="line-546">      private static final class ParameterTokenSubclass extends ParameterToken {</span>
<span class="source-line-no">547</span><span id="line-547"></span>
<span class="source-line-no">548</span><span id="line-548"></span>
<span class="source-line-no">549</span><span id="line-549">        /*</span>
<span class="source-line-no">550</span><span id="line-550">         * Constructors.</span>
<span class="source-line-no">551</span><span id="line-551">         */</span>
<span class="source-line-no">552</span><span id="line-552"></span>
<span class="source-line-no">553</span><span id="line-553"></span>
<span class="source-line-no">554</span><span id="line-554">        private ParameterTokenSubclass(final String name, final Integer modifiers) {</span>
<span class="source-line-no">555</span><span id="line-555">          super(name, modifiers);</span>
<span class="source-line-no">556</span><span id="line-556">        }</span>
<span class="source-line-no">557</span><span id="line-557"></span>
<span class="source-line-no">558</span><span id="line-558">      }</span>
<span class="source-line-no">559</span><span id="line-559"></span>
<span class="source-line-no">560</span><span id="line-560">    }</span>
<span class="source-line-no">561</span><span id="line-561"></span>
<span class="source-line-no">562</span><span id="line-562">  }</span>
<span class="source-line-no">563</span><span id="line-563"></span>
<span class="source-line-no">564</span><span id="line-564">}</span>




























































</pre>
</div>
</main>
</body>
</html>